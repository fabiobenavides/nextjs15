
If you have code that must never end up on the client-side (no matter if it's a server action or not), you should instead use the server-only package as described here.

https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#keeping-server-only-code-out-of-the-client-environment


Running Prod mode:
npm run build
npm start

Prod code: ./next folder


4 types of cache: https://nextjs.org/docs/app/building-your-application/caching

Next 15+ cache is less agressive

Way to control the cache:

1- In the specific fetch
const response = await fetch('http://localhost:8080/messages', {
    //cache: 'no-store', //next 14 default 'force-cache' -- next 15 default 'no-store' less agressive OR
    next: {
      revalidate: 5 //seconds for next revalidate cache
    }
  });

2- export variables any of these 2:

export const revalidate = 5; //revalidate for the entire page in case there are multiples request
export const dynamic = 'force-dynamic'; //'force-dynamic' same as fetch: cache: 'no-store'

3- Inside a component function

unstable_noStore(); //same as no-store


4- revalidatePath or revalidateTag
revalidatePath('/messages'); //This is better, more efficient, for nested content: add a second parameter: , 'layout' 

revalidateTag('msg'); //if you assign tags to the request
Example:
const response = await fetch('http://localhost:8080/messages', {
  next: {tags: ['msg', 'msg2']}
});

5- cache react function

example:
export const getMessages = cache(function getMessages() {
  console.log('Fetching messages from db');
  return db.prepare('SELECT * FROM messages').all();
});

-------------------
Hooks:

  useState -> state
  useEffect -> life cycle
  useRouter -> navigation (router.push, router.replace, etc) //replace current history entry (no back possible)
  useSearchParams -> read query string
  usePathname -> read current path
  useParams -> read dynamic route values
  useTransition -> for pending state when doing something async (like a form submission)
  useFormState (nextjs 14) / useActionState (nextjs 15) -> for form submission state

-------------------

"export": "next export" //Prodce 100% static HTML files / No server needed / Bt not for dynamic pages, API routes, or server-side rendering

Pre-rendering:

1- Static Generation:
	Pre-render at build time, and the result will be cached for the lifetime of the app. 
	This is useful for data that doesn't change often, like a blog post or a product page.
    You can add a revalidate property to the returned object to specify how often the page should be re-generated.

    //only in component files, inside the pages folder
	export async fuction getStaticProps (context) {
		//execute any code
    const meetpupId = context.params.meetupId;
    //fetch data for a single meetup

		//return an object like: 
    return {
      props: {
        //object with the properties expected
      },
      revalidate:  10 //Seconds
    }
  }

  //needed for getStaticProps with dynamic routes
  //return all the possible values for the dynamic part of the URL
  export async fuction getStaticPaths (only in component files, inside the pages folder) {
    //execute any code
    //we can fetch all meetups to return an array of their IDs
    //return an object like:  
    return {
      paths: [
        { params: { meetupId: '1' } },  
        { params: { meetupId: '2' } }
      ],
      fallback: false //or true or 'blocking'
      //false: any paths not returned by getStaticPaths will result in a 404 page
      //true: the behavior is the same as false, but the page will be generated on the fly in the first request
      //'blocking': the user won't see anything until the page is generated, then it will be cached
    } 
  }

	
2- Server-side rendering:
	
	Always right on the server, never on the client
  for any incoming request
  Useful for data that changes often, like a user profile or a dashboard.
  You can add a cache property to the fetch request to specify how the data should be cached.

	
	export async fuction getServerSideProps(context) {

    //Access request and response objects
    const req = context.req;
    const res = context.res;

    return {
      props: {
        // props for your component
      },
    }
  }
	
-------------------

API routes:

pages/api/

Only server side code
Can be used to handle form submissions, 
interact with a database, 
or perform any other server-side logic.


-------------------


React router:

react-router-dom (for client side rendering)